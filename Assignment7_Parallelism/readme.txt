Assignment 7: Multithreaded Performance - log.txt
--------------------------------------------------------------------------------

In the homework for Assignment 7, we took the ray tracer code and parallelized
it by modifying main.c and Makefile. We added -lpthread to the Makefile
libraries and mainly edited the main function of main.c.

Prior to modification, main.c iterated through every pixel in an image and
calculated the three associated color values with each (x, y) and printed the
calculated color values. This required nested for loops that performed the same
function for each pixel.

In order to parallelize this, we removed the declaration of functions and the
calculation of the color values from the main function and put it in a new void
* function named calc_colors(). The function took a void pointer that could be
casted and dereferenced into an int value of the number of threads we were
working with.

Any variables declared in the main function that were used in both main and the
newly formed calc_colors() function were made global so they were accessible by
both functions. This is one issue I encountered when a local value only
pertained to main() when it was also used in calc_colors(). By making it global,
it resolves this issue, as it did for scene_t scene and int nthreads.

We moved the calculations into a separate function because pthread_create calls
a function after each thread is created, but it can only take in a function
pointer to one function, so we used calc_colors as this function. calc_colors()
had to be a void * function that returned NULL at the end of the function.
Returning NULL was something I missed initially, resulting in some bugs. The
argument was a malloced array of the thread IDs. We then passed in a reference
to these IDs to the argument for calc_colors, and in calc_colors cast the void *
argument to an integer pointer that was then dereferenced to get the value of
the thread ID.

Each image was treated as a 2D array that was broken up into vertical sections
of width nthread. The 1st thread would act on the 1st column of each section and
the nth thread would work on the nth column of each section. We had declared a
3D array as a global array that had a size of width by height by 3 since there
are 3 color values at every (x, y). Using calc_colors, we filled the 3 color
values at every (x, y) in the 3D array.

Back in the main function, we then used pthread_join to join threads after
threading completed and prevent any thread from being aborted early. We could
then print all the values of the 3D matrix we had created and verify visually
whether it had worked with gimp, or verify byte-by-byte with compare or diff
commands between baseline.ppm and the 1-test.ppm through 8-test.ppm files
generated by make check clean.

The results of the election when run under different numbers of threads are as
follows according to the terminal output of make check clean:

time ./srt 1-test.ppm >1-test.ppm.tmp

real  0m53.676s
user  0m53.660s
sys   0m0.004s

time ./srt 2-test.ppm >2-test.ppm.tmp

real  0m27.092s
user  0m54.040s
sys   0m0.002s

time ./srt 4-test.ppm >4-test.ppm.tmp

real  0m14.170s
user  0m56.084s
sys   0m0.001s

time ./srt 8-test.ppm >8-test.ppm.tmp

real  0m7.306s
user  0m56.158s
sys   0m0.002s

We can see that as the number of threads increases, real time decreases while
system and user time seems rather the same. This is because as the image is
split into vertical sections, threads can operate on their portion of the image
concurrently and less real time is required to go through all the pixels and
perform the calculations to get the three color values at every (x, y).

At a certain point, too many threads can be detrimental to performance as
thread_creation takes unnecessary resources and there are more threads than
optimal to divide the image into workable columns. As we can see with the
following, 32 threads results in a much slower user time, meaning that
parallelization with too many threads adds a lot to the CPU time used by the
process. Compared to ./srt with 8 threads, real time may be faster but user time
is less efficient and leads to worse performance there.

$ time ./srt 32-test.ppm >32-test.ppm.tmp

real  0m3.828s
user  1m38.618s
sys   0m0.006s

However, up to an excessive number of threads, our parallelization for main.c
seems to have significantly decreased run time for the program, showing that
performance has improved significantly without affecting the results.

To verify that the parallelized version operates the same as the original, we
can perform the following command to make sure the bytes are identical:

$ diff baseline.ppm 1-test.ppm -s Files baseline.ppm and 1-test.ppm are
identical
